<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: south.creator.changes</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="south.creator.actions.html">south.creator.actions</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="south.creator.freezer.html">south.creator.freezer</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">south.creator.changes</span>:
    260 total statements,
    <span class="critical">0.0% covered</span>
  </h1>
  <p>Generated: Sat 2014-12-06 15:16 UTC</p>
  <p>Source file: /home/nkt/venv/lib/python2.7/site-packages/south/creator/changes.py</p>
  <p>
    Stats:
    <span class="executed">0 executed</span>,
    <span class="missed">253 missed</span>,
    <span class="excluded">7 excluded</span>,
    <span class="ignored">246 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="ignored"><code>"""</code></li>
<li class="ignored"><code>Contains things to detect changes - either using options passed in on the</code></li>
<li class="ignored"><code>commandline, or by using autodetection, etc.</code></li>
<li class="ignored"><code>"""</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from __future__ import print_function</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.contrib.contenttypes.generic import GenericRelation</code></li>
<li class="excluded"><code>from django.utils.datastructures import SortedDict</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from south.creator.freezer import remove_useless_attributes, freeze_apps, model_key</code></li>
<li class="excluded"><code>from south.utils import auto_through</code></li>
<li class="excluded"><code>from south.utils.py3 import string_types</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class BaseChanges(object):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Base changes class.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def suggest_name(self):</code></li>
<li class="missed"><code>        return ''</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def split_model_def(self, model, model_def):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Given a model and its model def (a dict of field: triple), returns three</code></li>
<li class="ignored"><code>        items: the real fields dict, the Meta dict, and the M2M fields dict.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        real_fields = SortedDict()</code></li>
<li class="missed"><code>        meta = SortedDict()</code></li>
<li class="missed"><code>        m2m_fields = SortedDict()</code></li>
<li class="missed"><code>        for name, triple in model_def.items():</code></li>
<li class="missed"><code>            if name == "Meta":</code></li>
<li class="missed"><code>                meta = triple</code></li>
<li class="missed"><code>            elif isinstance(model._meta.get_field_by_name(name)[0], models.ManyToManyField):</code></li>
<li class="missed"><code>                m2m_fields[name] = triple</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                real_fields[name] = triple</code></li>
<li class="missed"><code>        return real_fields, meta, m2m_fields</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def current_model_from_key(self, key):</code></li>
<li class="missed"><code>        app_label, model_name = key.split(".")</code></li>
<li class="missed"><code>        return models.get_model(app_label, model_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def current_field_from_key(self, key, fieldname):</code></li>
<li class="missed"><code>        app_label, model_name = key.split(".")</code></li>
<li class="ignored"><code>        # Special, for the magical field from order_with_respect_to</code></li>
<li class="missed"><code>        if fieldname == "_order":</code></li>
<li class="missed"><code>            field = models.IntegerField()</code></li>
<li class="missed"><code>            field.name = "_order"</code></li>
<li class="missed"><code>            field.attname = "_order"</code></li>
<li class="missed"><code>            field.column = "_order"</code></li>
<li class="missed"><code>            field.default = 0</code></li>
<li class="missed"><code>            return field</code></li>
<li class="ignored"><code>        # Otherwise, normal.</code></li>
<li class="missed"><code>        return models.get_model(app_label, model_name)._meta.get_field_by_name(fieldname)[0]</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class AutoChanges(BaseChanges):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Detects changes by 'diffing' two sets of frozen model definitions.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Field types we don't generate add/remove field changes for.</code></li>
<li class="missed"><code>    IGNORED_FIELD_TYPES = [</code></li>
<li class="ignored"><code>        GenericRelation,</code></li>
<li class="ignored"><code>    ]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, migrations, old_defs, old_orm, new_defs):</code></li>
<li class="missed"><code>        self.migrations = migrations</code></li>
<li class="missed"><code>        self.old_defs = old_defs</code></li>
<li class="missed"><code>        self.old_orm = old_orm</code></li>
<li class="missed"><code>        self.new_defs = new_defs</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def suggest_name(self):</code></li>
<li class="missed"><code>        parts = ["auto"]</code></li>
<li class="missed"><code>        for change_name, params in self.get_changes():</code></li>
<li class="missed"><code>            if change_name == "AddModel":</code></li>
<li class="missed"><code>                parts.append("add_%s" % params['model']._meta.object_name.lower())</code></li>
<li class="missed"><code>            elif change_name == "DeleteModel":</code></li>
<li class="missed"><code>                parts.append("del_%s" % params['model']._meta.object_name.lower())</code></li>
<li class="missed"><code>            elif change_name == "AddField":</code></li>
<li class="missed"><code>                parts.append("add_field_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    params['field'].name,</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "DeleteField":</code></li>
<li class="missed"><code>                parts.append("del_field_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    params['field'].name,</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "ChangeField":</code></li>
<li class="missed"><code>                parts.append("chg_field_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    params['new_field'].name,</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "AddUnique":</code></li>
<li class="missed"><code>                parts.append("add_unique_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    "_".join([x.name for x in params['fields']]),</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "DeleteUnique":</code></li>
<li class="missed"><code>                parts.append("del_unique_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    "_".join([x.name for x in params['fields']]),</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "AddIndex":</code></li>
<li class="missed"><code>                parts.append("add_index_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    "_".join([x.name for x in params['fields']]),</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>            elif change_name == "DeleteIndex":</code></li>
<li class="missed"><code>                parts.append("del_index_%s_%s" % (</code></li>
<li class="ignored"><code>                    params['model']._meta.object_name.lower(),</code></li>
<li class="ignored"><code>                    "_".join([x.name for x in params['fields']]),</code></li>
<li class="ignored"><code>                ))</code></li>
<li class="missed"><code>        return ("__".join(parts))[:70]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_changes(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns the difference between the old and new sets of models as a 5-tuple:</code></li>
<li class="ignored"><code>        added_models, deleted_models, added_fields, deleted_fields, changed_fields</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        deleted_models = set()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # See if anything's vanished</code></li>
<li class="missed"><code>        for key in self.old_defs:</code></li>
<li class="missed"><code>            if key not in self.new_defs:</code></li>
<li class="ignored"><code>                # We shouldn't delete it if it was managed=False</code></li>
<li class="missed"><code>                old_fields, old_meta, old_m2ms = self.split_model_def(self.old_orm[key], self.old_defs[key])</code></li>
<li class="missed"><code>                if old_meta.get("managed", "True") != "False":</code></li>
<li class="ignored"><code>                    # Alright, delete it.</code></li>
<li class="missed"><code>                    yield ("DeleteModel", {</code></li>
<li class="ignored"><code>                        "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                        "model_def": old_fields,</code></li>
<li class="ignored"><code>                    })</code></li>
<li class="ignored"><code>                    # Also make sure we delete any M2Ms it had.</code></li>
<li class="missed"><code>                    for fieldname in old_m2ms:</code></li>
<li class="ignored"><code>                        # Only delete its stuff if it wasn't a through=.</code></li>
<li class="missed"><code>                        field = self.old_orm[key + ":" + fieldname]</code></li>
<li class="missed"><code>                        if auto_through(field):</code></li>
<li class="missed"><code>                            yield ("DeleteM2M", {"model": self.old_orm[key], "field": field})</code></li>
<li class="ignored"><code>                    # And any index/uniqueness constraints it had</code></li>
<li class="missed"><code>                    for attr, operation in (("unique_together", "DeleteUnique"), ("index_together", "DeleteIndex")):</code></li>
<li class="missed"><code>                        together = eval(old_meta.get(attr, "[]"))</code></li>
<li class="missed"><code>                        if together:</code></li>
<li class="ignored"><code>                            # If it's only a single tuple, make it into the longer one</code></li>
<li class="missed"><code>                            if isinstance(together[0], string_types):</code></li>
<li class="missed"><code>                                together = [together]</code></li>
<li class="ignored"><code>                            # For each combination, make an action for it</code></li>
<li class="missed"><code>                            for fields in together:</code></li>
<li class="missed"><code>                                yield (operation, {</code></li>
<li class="ignored"><code>                                    "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                                    "fields": [self.old_orm[key]._meta.get_field_by_name(x)[0] for x in fields],</code></li>
<li class="ignored"><code>                                })</code></li>
<li class="ignored"><code>                # We always add it in here so we ignore it later</code></li>
<li class="missed"><code>                deleted_models.add(key)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Or appeared</code></li>
<li class="missed"><code>        for key in self.new_defs:</code></li>
<li class="missed"><code>            if key not in self.old_defs:</code></li>
<li class="ignored"><code>                # We shouldn't add it if it's managed=False</code></li>
<li class="missed"><code>                new_fields, new_meta, new_m2ms = self.split_model_def(self.current_model_from_key(key), self.new_defs[key])</code></li>
<li class="missed"><code>                if new_meta.get("managed", "True") != "False":</code></li>
<li class="missed"><code>                    yield ("AddModel", {</code></li>
<li class="ignored"><code>                        "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                        "model_def": new_fields,</code></li>
<li class="ignored"><code>                    })</code></li>
<li class="ignored"><code>                    # Also make sure we add any M2Ms it has.</code></li>
<li class="missed"><code>                    for fieldname in new_m2ms:</code></li>
<li class="ignored"><code>                        # Only create its stuff if it wasn't a through=.</code></li>
<li class="missed"><code>                        field = self.current_field_from_key(key, fieldname)</code></li>
<li class="missed"><code>                        if auto_through(field):</code></li>
<li class="missed"><code>                            yield ("AddM2M", {"model": self.current_model_from_key(key), "field": field})</code></li>
<li class="ignored"><code>                    # And any index/uniqueness constraints it has</code></li>
<li class="missed"><code>                    for attr, operation in (("unique_together", "AddUnique"), ("index_together", "AddIndex")):</code></li>
<li class="missed"><code>                        together = eval(new_meta.get(attr, "[]"))</code></li>
<li class="missed"><code>                        if together:</code></li>
<li class="ignored"><code>                            # If it's only a single tuple, make it into the longer one</code></li>
<li class="missed"><code>                            if isinstance(together[0], string_types):</code></li>
<li class="missed"><code>                                together = [together]</code></li>
<li class="ignored"><code>                            # For each combination, make an action for it</code></li>
<li class="missed"><code>                            for fields in together:</code></li>
<li class="missed"><code>                                yield (operation, {</code></li>
<li class="ignored"><code>                                    "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                                    "fields": [self.current_model_from_key(key)._meta.get_field_by_name(x)[0] for x in fields],</code></li>
<li class="ignored"><code>                                })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Now, for every model that's stayed the same, check its fields.</code></li>
<li class="missed"><code>        for key in self.old_defs:</code></li>
<li class="missed"><code>            if key not in deleted_models:</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                old_fields, old_meta, old_m2ms = self.split_model_def(self.old_orm[key], self.old_defs[key])</code></li>
<li class="missed"><code>                new_fields, new_meta, new_m2ms = self.split_model_def(self.current_model_from_key(key), self.new_defs[key])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # Do nothing for models which are now not managed.</code></li>
<li class="missed"><code>                if new_meta.get("managed", "True") == "False":</code></li>
<li class="missed"><code>                    continue</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # Find fields that have vanished.</code></li>
<li class="missed"><code>                for fieldname in old_fields:</code></li>
<li class="missed"><code>                    if fieldname not in new_fields:</code></li>
<li class="ignored"><code>                        # Don't do it for any fields we're ignoring</code></li>
<li class="missed"><code>                        field = self.old_orm[key + ":" + fieldname]</code></li>
<li class="missed"><code>                        field_allowed = True</code></li>
<li class="missed"><code>                        for field_type in self.IGNORED_FIELD_TYPES:</code></li>
<li class="missed"><code>                            if isinstance(field, field_type):</code></li>
<li class="missed"><code>                                field_allowed = False</code></li>
<li class="missed"><code>                        if field_allowed:</code></li>
<li class="ignored"><code>                            # Looks alright.</code></li>
<li class="missed"><code>                            yield ("DeleteField", {</code></li>
<li class="ignored"><code>                                "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                                "field": field,</code></li>
<li class="ignored"><code>                                "field_def": old_fields[fieldname],</code></li>
<li class="ignored"><code>                            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # And ones that have appeared</code></li>
<li class="missed"><code>                for fieldname in new_fields:</code></li>
<li class="missed"><code>                    if fieldname not in old_fields:</code></li>
<li class="ignored"><code>                        # Don't do it for any fields we're ignoring</code></li>
<li class="missed"><code>                        field = self.current_field_from_key(key, fieldname)</code></li>
<li class="missed"><code>                        field_allowed = True</code></li>
<li class="missed"><code>                        for field_type in self.IGNORED_FIELD_TYPES:</code></li>
<li class="missed"><code>                            if isinstance(field, field_type):</code></li>
<li class="missed"><code>                                field_allowed = False</code></li>
<li class="missed"><code>                        if field_allowed:</code></li>
<li class="ignored"><code>                            # Looks alright.</code></li>
<li class="missed"><code>                            yield ("AddField", {</code></li>
<li class="ignored"><code>                                "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                                "field": field,</code></li>
<li class="ignored"><code>                                "field_def": new_fields[fieldname],</code></li>
<li class="ignored"><code>                            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # Find M2Ms that have vanished</code></li>
<li class="missed"><code>                for fieldname in old_m2ms:</code></li>
<li class="missed"><code>                    if fieldname not in new_m2ms:</code></li>
<li class="ignored"><code>                        # Only delete its stuff if it wasn't a through=.</code></li>
<li class="missed"><code>                        field = self.old_orm[key + ":" + fieldname]</code></li>
<li class="missed"><code>                        if auto_through(field):</code></li>
<li class="missed"><code>                            yield ("DeleteM2M", {"model": self.old_orm[key], "field": field})</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # Find M2Ms that have appeared</code></li>
<li class="missed"><code>                for fieldname in new_m2ms:</code></li>
<li class="missed"><code>                    if fieldname not in old_m2ms:</code></li>
<li class="ignored"><code>                        # Only create its stuff if it wasn't a through=.</code></li>
<li class="missed"><code>                        field = self.current_field_from_key(key, fieldname)</code></li>
<li class="missed"><code>                        if auto_through(field):</code></li>
<li class="missed"><code>                            yield ("AddM2M", {"model": self.current_model_from_key(key), "field": field})</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # For the ones that exist in both models, see if they were changed</code></li>
<li class="missed"><code>                for fieldname in set(old_fields).intersection(set(new_fields)):</code></li>
<li class="ignored"><code>                    # Non-index changes</code></li>
<li class="missed"><code>                    if self.different_attributes(</code></li>
<li class="ignored"><code>                     remove_useless_attributes(old_fields[fieldname], True, True),</code></li>
<li class="ignored"><code>                     remove_useless_attributes(new_fields[fieldname], True, True)):</code></li>
<li class="missed"><code>                        yield ("ChangeField", {</code></li>
<li class="ignored"><code>                            "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                            "old_field": self.old_orm[key + ":" + fieldname],</code></li>
<li class="ignored"><code>                            "new_field": self.current_field_from_key(key, fieldname),</code></li>
<li class="ignored"><code>                            "old_def": old_fields[fieldname],</code></li>
<li class="ignored"><code>                            "new_def": new_fields[fieldname],</code></li>
<li class="ignored"><code>                        })</code></li>
<li class="ignored"><code>                    # Index changes</code></li>
<li class="missed"><code>                    old_field = self.old_orm[key + ":" + fieldname]</code></li>
<li class="missed"><code>                    new_field = self.current_field_from_key(key, fieldname)</code></li>
<li class="missed"><code>                    if not old_field.db_index and new_field.db_index:</code></li>
<li class="ignored"><code>                        # They've added an index.</code></li>
<li class="missed"><code>                        yield ("AddIndex", {</code></li>
<li class="ignored"><code>                            "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                            "fields": [new_field],</code></li>
<li class="ignored"><code>                        })</code></li>
<li class="missed"><code>                    if old_field.db_index and not new_field.db_index:</code></li>
<li class="ignored"><code>                        # They've removed an index.</code></li>
<li class="missed"><code>                        yield ("DeleteIndex", {</code></li>
<li class="ignored"><code>                            "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                            "fields": [old_field],</code></li>
<li class="ignored"><code>                        })</code></li>
<li class="ignored"><code>                    # See if their uniques have changed</code></li>
<li class="missed"><code>                    if old_field.unique != new_field.unique:</code></li>
<li class="ignored"><code>                        # Make sure we look at the one explicitly given to see what happened</code></li>
<li class="missed"><code>                        if new_field.unique:</code></li>
<li class="missed"><code>                            yield ("AddUnique", {</code></li>
<li class="ignored"><code>                                "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                                "fields": [new_field],</code></li>
<li class="ignored"><code>                            })</code></li>
<li class="ignored"><code>                        else:</code></li>
<li class="missed"><code>                            yield ("DeleteUnique", {</code></li>
<li class="ignored"><code>                                "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                                "fields": [old_field],</code></li>
<li class="ignored"><code>                            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                # See if there's any M2Ms that have changed.</code></li>
<li class="missed"><code>                for fieldname in set(old_m2ms).intersection(set(new_m2ms)):</code></li>
<li class="missed"><code>                    old_field = self.old_orm[key + ":" + fieldname]</code></li>
<li class="missed"><code>                    new_field = self.current_field_from_key(key, fieldname)</code></li>
<li class="ignored"><code>                    # Have they _added_ a through= ?</code></li>
<li class="missed"><code>                    if auto_through(old_field) and not auto_through(new_field):</code></li>
<li class="missed"><code>                        yield ("DeleteM2M", {"model": self.old_orm[key], "field": old_field})</code></li>
<li class="ignored"><code>                    # Have they _removed_ a through= ?</code></li>
<li class="missed"><code>                    if not auto_through(old_field) and auto_through(new_field):</code></li>
<li class="missed"><code>                        yield ("AddM2M", {"model": self.current_model_from_key(key), "field": new_field})</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>                ## See if the {index,unique}_togethers have changed</code></li>
<li class="missed"><code>                for attr, add_operation, del_operation in (("unique_together", "AddUnique", "DeleteUnique"), ("index_together", "AddIndex", "DeleteIndex")):</code></li>
<li class="ignored"><code>                    # First, normalise them into lists of sets.</code></li>
<li class="missed"><code>                    old_together = eval(old_meta.get(attr, "[]"))</code></li>
<li class="missed"><code>                    new_together = eval(new_meta.get(attr, "[]"))</code></li>
<li class="missed"><code>                    if old_together and isinstance(old_together[0], string_types):</code></li>
<li class="missed"><code>                        old_together = [old_together]</code></li>
<li class="missed"><code>                    if new_together and isinstance(new_together[0], string_types):</code></li>
<li class="missed"><code>                        new_together = [new_together]</code></li>
<li class="missed"><code>                    old_together = frozenset(tuple(o) for o in old_together)</code></li>
<li class="missed"><code>                    new_together = frozenset(tuple(n) for n in new_together)</code></li>
<li class="ignored"><code>                    # See if any appeared or disappeared</code></li>
<li class="missed"><code>                    disappeared = old_together.difference(new_together)</code></li>
<li class="missed"><code>                    appeared = new_together.difference(old_together)</code></li>
<li class="missed"><code>                    for item in disappeared:</code></li>
<li class="missed"><code>                        yield (del_operation, {</code></li>
<li class="ignored"><code>                            "model": self.old_orm[key],</code></li>
<li class="ignored"><code>                            "fields": [self.old_orm[key + ":" + x] for x in item],</code></li>
<li class="ignored"><code>                        })</code></li>
<li class="missed"><code>                    for item in appeared:</code></li>
<li class="missed"><code>                        yield (add_operation, {</code></li>
<li class="ignored"><code>                            "model": self.current_model_from_key(key),</code></li>
<li class="ignored"><code>                            "fields": [self.current_field_from_key(key, x) for x in item],</code></li>
<li class="ignored"><code>                        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @classmethod</code></li>
<li class="ignored"><code>    def is_triple(cls, triple):</code></li>
<li class="ignored"><code>        "Returns whether the argument is a triple."</code></li>
<li class="missed"><code>        return isinstance(triple, (list, tuple)) and len(triple) == 3 and \</code></li>
<li class="ignored"><code>            isinstance(triple[0], string_types) and \</code></li>
<li class="ignored"><code>            isinstance(triple[1], (list, tuple)) and \</code></li>
<li class="ignored"><code>            isinstance(triple[2], dict)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @classmethod</code></li>
<li class="ignored"><code>    def different_attributes(cls, old, new):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Backwards-compat comparison that ignores orm. on the RHS and not the left</code></li>
<li class="ignored"><code>        and which knows django.db.models.fields.CharField = models.CharField.</code></li>
<li class="ignored"><code>        Has a whole load of tests in tests/autodetection.py.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If they're not triples, just do normal comparison</code></li>
<li class="missed"><code>        if not cls.is_triple(old) or not cls.is_triple(new):</code></li>
<li class="missed"><code>            return old != new</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Expand them out into parts</code></li>
<li class="missed"><code>        old_field, old_pos, old_kwd = old</code></li>
<li class="missed"><code>        new_field, new_pos, new_kwd = new</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Copy the positional and keyword arguments so we can compare them and pop off things</code></li>
<li class="missed"><code>        old_pos, new_pos = old_pos[:], new_pos[:]</code></li>
<li class="missed"><code>        old_kwd = dict(old_kwd.items())</code></li>
<li class="missed"><code>        new_kwd = dict(new_kwd.items())</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Remove comparison of the existence of 'unique', that's done elsewhere.</code></li>
<li class="ignored"><code>        # TODO: Make this work for custom fields where unique= means something else?</code></li>
<li class="missed"><code>        if "unique" in old_kwd:</code></li>
<li class="missed"><code>            del old_kwd['unique']</code></li>
<li class="missed"><code>        if "unique" in new_kwd:</code></li>
<li class="missed"><code>            del new_kwd['unique']</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If the first bit is different, check it's not by dj.db.models...</code></li>
<li class="missed"><code>        if old_field != new_field:</code></li>
<li class="missed"><code>            if old_field.startswith("models.") and (new_field.startswith("django.db.models") \</code></li>
<li class="ignored"><code>             or new_field.startswith("django.contrib.gis")):</code></li>
<li class="missed"><code>                if old_field.split(".")[-1] != new_field.split(".")[-1]:</code></li>
<li class="missed"><code>                    return True</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="ignored"><code>                    # Remove those fields from the final comparison</code></li>
<li class="missed"><code>                    old_field = new_field = ""</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If there's a positional argument in the first, and a 'to' in the second,</code></li>
<li class="ignored"><code>        # see if they're actually comparable.</code></li>
<li class="missed"><code>        if (old_pos and "to" in new_kwd) and ("orm" in new_kwd['to'] and "orm" not in old_pos[0]):</code></li>
<li class="ignored"><code>            # Do special comparison to fix #153</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                if old_pos[0] != new_kwd['to'].split("'")[1].split(".")[1]:</code></li>
<li class="missed"><code>                    return True</code></li>
<li class="missed"><code>            except IndexError:</code></li>
<li class="missed"><code>                pass # Fall back to next comparison</code></li>
<li class="ignored"><code>            # Remove those attrs from the final comparison</code></li>
<li class="missed"><code>            old_pos = old_pos[1:]</code></li>
<li class="missed"><code>            del new_kwd['to']</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return old_field != new_field or old_pos != new_pos or old_kwd != new_kwd</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class ManualChanges(BaseChanges):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Detects changes by reading the command line.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, migrations, added_models, added_fields, added_indexes):</code></li>
<li class="missed"><code>        self.migrations = migrations</code></li>
<li class="missed"><code>        self.added_models = added_models</code></li>
<li class="missed"><code>        self.added_fields = added_fields</code></li>
<li class="missed"><code>        self.added_indexes = added_indexes</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def suggest_name(self):</code></li>
<li class="missed"><code>        bits = []</code></li>
<li class="missed"><code>        for model_name in self.added_models:</code></li>
<li class="missed"><code>            bits.append('add_model_%s' % model_name)</code></li>
<li class="missed"><code>        for field_name in self.added_fields:</code></li>
<li class="missed"><code>            bits.append('add_field_%s' % field_name)</code></li>
<li class="missed"><code>        for index_name in self.added_indexes:</code></li>
<li class="missed"><code>            bits.append('add_index_%s' % index_name)</code></li>
<li class="missed"><code>        return '_'.join(bits).replace('.', '_')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_changes(self):</code></li>
<li class="ignored"><code>        # Get the model defs so we can use them for the yield later</code></li>
<li class="missed"><code>        model_defs = freeze_apps([self.migrations.app_label()])</code></li>
<li class="ignored"><code>        # Make the model changes</code></li>
<li class="missed"><code>        for model_name in self.added_models:</code></li>
<li class="missed"><code>            model = models.get_model(self.migrations.app_label(), model_name)</code></li>
<li class="missed"><code>            real_fields, meta, m2m_fields = self.split_model_def(model, model_defs[model_key(model)])</code></li>
<li class="missed"><code>            yield ("AddModel", {</code></li>
<li class="ignored"><code>                "model": model,</code></li>
<li class="ignored"><code>                "model_def": real_fields,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code>        # And the field changes</code></li>
<li class="missed"><code>        for field_desc in self.added_fields:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                model_name, field_name = field_desc.split(".")</code></li>
<li class="missed"><code>            except (TypeError, ValueError):</code></li>
<li class="missed"><code>                raise ValueError("%r is not a valid field description." % field_desc)</code></li>
<li class="missed"><code>            model = models.get_model(self.migrations.app_label(), model_name)</code></li>
<li class="missed"><code>            real_fields, meta, m2m_fields = self.split_model_def(model, model_defs[model_key(model)])</code></li>
<li class="missed"><code>            yield ("AddField", {</code></li>
<li class="ignored"><code>                "model": model,</code></li>
<li class="ignored"><code>                "field": model._meta.get_field_by_name(field_name)[0],</code></li>
<li class="ignored"><code>                "field_def": real_fields[field_name],</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code>        # And the indexes</code></li>
<li class="missed"><code>        for field_desc in self.added_indexes:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                model_name, field_name = field_desc.split(".")</code></li>
<li class="missed"><code>            except (TypeError, ValueError):</code></li>
<li class="missed"><code>                print("%r is not a valid field description." % field_desc)</code></li>
<li class="missed"><code>            model = models.get_model(self.migrations.app_label(), model_name)</code></li>
<li class="missed"><code>            yield ("AddIndex", {</code></li>
<li class="ignored"><code>                "model": model,</code></li>
<li class="ignored"><code>                "fields": [model._meta.get_field_by_name(field_name)[0]],</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class InitialChanges(BaseChanges):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Creates all models; handles --initial.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def suggest_name(self):</code></li>
<li class="missed"><code>        return 'initial'</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, migrations):</code></li>
<li class="missed"><code>        self.migrations = migrations</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_changes(self):</code></li>
<li class="ignored"><code>        # Get the frozen models for this app</code></li>
<li class="missed"><code>        model_defs = freeze_apps([self.migrations.app_label()])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for model in models.get_models(models.get_app(self.migrations.app_label())):</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Don't do anything for unmanaged, abstract or proxy models</code></li>
<li class="missed"><code>            if model._meta.abstract or getattr(model._meta, "proxy", False) or not getattr(model._meta, "managed", True):</code></li>
<li class="missed"><code>                continue</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>            real_fields, meta, m2m_fields = self.split_model_def(model, model_defs[model_key(model)])</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Firstly, add the main table and fields</code></li>
<li class="missed"><code>            yield ("AddModel", {</code></li>
<li class="ignored"><code>                "model": model,</code></li>
<li class="ignored"><code>                "model_def": real_fields,</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Then, add any indexing/uniqueness that's around</code></li>
<li class="missed"><code>            if meta:</code></li>
<li class="missed"><code>                for attr, operation in (("unique_together", "AddUnique"), ("index_together", "AddIndex")):</code></li>
<li class="missed"><code>                    together = eval(meta.get(attr, "[]"))</code></li>
<li class="missed"><code>                    if together:</code></li>
<li class="ignored"><code>                        # If it's only a single tuple, make it into the longer one</code></li>
<li class="missed"><code>                        if isinstance(together[0], string_types):</code></li>
<li class="missed"><code>                            together = [together]</code></li>
<li class="ignored"><code>                        # For each combination, make an action for it</code></li>
<li class="missed"><code>                        for fields in together:</code></li>
<li class="missed"><code>                            yield (operation, {</code></li>
<li class="ignored"><code>                                "model": model,</code></li>
<li class="ignored"><code>                                "fields": [model._meta.get_field_by_name(x)[0] for x in fields],</code></li>
<li class="ignored"><code>                            })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Finally, see if there's some M2M action</code></li>
<li class="missed"><code>            for name, triple in m2m_fields.items():</code></li>
<li class="missed"><code>                field = model._meta.get_field_by_name(name)[0]</code></li>
<li class="ignored"><code>                # But only if it's not through=foo (#120)</code></li>
<li class="missed"><code>                if field.rel.through:</code></li>
<li class="missed"><code>                    try:</code></li>
<li class="ignored"><code>                        # Django 1.1 and below</code></li>
<li class="missed"><code>                        through_model = field.rel.through_model</code></li>
<li class="missed"><code>                    except AttributeError:</code></li>
<li class="ignored"><code>                        # Django 1.2</code></li>
<li class="missed"><code>                        through_model = field.rel.through</code></li>
<li class="missed"><code>                if (not field.rel.through) or getattr(through_model._meta, "auto_created", False):</code></li>
<li class="missed"><code>                    yield ("AddM2M", {</code></li>
<li class="ignored"><code>                        "model": model,</code></li>
<li class="ignored"><code>                        "field": field,</code></li>
<li class="ignored"><code>                    })</code></li>
  </ol>
</div>

<div class="nav">
  <a href="south.creator.actions.html">south.creator.actions</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="south.creator.freezer.html">south.creator.freezer</a>
</div>

  </body>
</html>

