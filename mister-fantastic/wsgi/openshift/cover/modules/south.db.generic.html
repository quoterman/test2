<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: south.db.generic</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="south.db.firebird.html">south.db.firebird</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="south.db.mysql.html">south.db.mysql</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">south.db.generic</span>:
    585 total statements,
    <span class="critical">25.8% covered</span>
  </h1>
  <p>Generated: Sat 2014-12-06 15:16 UTC</p>
  <p>Source file: /home/nkt/venv/lib/python2.7/site-packages/south/db/generic.py</p>
  <p>
    Stats:
    <span class="executed">146 executed</span>,
    <span class="missed">420 missed</span>,
    <span class="excluded">19 excluded</span>,
    <span class="ignored">579 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from __future__ import print_function</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>import re</code></li>
<li class="excluded"><code>import sys</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from django.core.management.color import no_style</code></li>
<li class="excluded"><code>from django.db import transaction, models</code></li>
<li class="excluded"><code>from django.db.utils import DatabaseError</code></li>
<li class="excluded"><code>from django.db.backends.util import truncate_name</code></li>
<li class="excluded"><code>from django.db.backends.creation import BaseDatabaseCreation</code></li>
<li class="excluded"><code>from django.db.models.fields import NOT_PROVIDED</code></li>
<li class="excluded"><code>from django.dispatch import dispatcher</code></li>
<li class="excluded"><code>from django.conf import settings</code></li>
<li class="excluded"><code>from django.utils.datastructures import SortedDict</code></li>
<li class="missed"><code>try:</code></li>
<li class="excluded"><code>    from django.utils.functional import cached_property</code></li>
<li class="missed"><code>except ImportError:</code></li>
<li class="missed"><code>    class cached_property(object):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Decorator that creates converts a method with a single</code></li>
<li class="ignored"><code>        self argument into a property cached on the instance.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        def __init__(self, func):</code></li>
<li class="missed"><code>            self.func = func</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        def __get__(self, instance, type):</code></li>
<li class="missed"><code>            res = instance.__dict__[self.func.__name__] = self.func(instance)</code></li>
<li class="missed"><code>            return res</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>from south.logger import get_logger</code></li>
<li class="excluded"><code>from south.utils.py3 import string_types, text_type</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def alias(attrname):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Returns a function which calls 'attrname' - for function aliasing.</code></li>
<li class="ignored"><code>    We can't just use foo = bar, as this breaks subclassing.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="missed"><code>    def func(self, *args, **kwds):</code></li>
<li class="missed"><code>        return getattr(self, attrname)(*args, **kwds)</code></li>
<li class="missed"><code>    return func</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def invalidate_table_constraints(func):</code></li>
<li class="missed"><code>    def _cache_clear(self, table, *args, **opts):</code></li>
<li class="executed"><code>        self._set_cache(table, value=INVALID)</code></li>
<li class="executed"><code>        return func(self, table, *args, **opts)</code></li>
<li class="missed"><code>    return _cache_clear</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def delete_column_constraints(func):</code></li>
<li class="missed"><code>    def _column_rm(self, table, column, *args, **opts):</code></li>
<li class="missed"><code>        self._set_cache(table, column, value=[])</code></li>
<li class="missed"><code>        return func(self, table, column, *args, **opts)</code></li>
<li class="missed"><code>    return _column_rm</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>def copy_column_constraints(func):</code></li>
<li class="missed"><code>    def _column_cp(self, table, column_old, column_new, *args, **opts):</code></li>
<li class="missed"><code>        db_name = self._get_setting('NAME')</code></li>
<li class="missed"><code>        self._set_cache(table, column_new, value=self.lookup_constraint(db_name, table, column_old))</code></li>
<li class="missed"><code>        return func(self, table, column_old, column_new, *args, **opts)</code></li>
<li class="missed"><code>    return _column_cp</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class INVALID(Exception):</code></li>
<li class="missed"><code>    def __repr__(self):</code></li>
<li class="missed"><code>        return 'INVALID'</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class DryRunError(ValueError):</code></li>
<li class="missed"><code>    pass</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>class DatabaseOperations(object):</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code>    Generic SQL implementation of the DatabaseOperations.</code></li>
<li class="ignored"><code>    Some of this code comes from Django Evolution.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    alter_string_set_type = 'ALTER COLUMN %(column)s TYPE %(type)s'</code></li>
<li class="missed"><code>    alter_string_set_null = 'ALTER COLUMN %(column)s DROP NOT NULL'</code></li>
<li class="missed"><code>    alter_string_drop_null = 'ALTER COLUMN %(column)s SET NOT NULL'</code></li>
<li class="missed"><code>    delete_check_sql = 'ALTER TABLE %(table)s DROP CONSTRAINT %(constraint)s'</code></li>
<li class="missed"><code>    add_column_string = 'ALTER TABLE %s ADD COLUMN %s;'</code></li>
<li class="missed"><code>    delete_unique_sql = "ALTER TABLE %s DROP CONSTRAINT %s"</code></li>
<li class="missed"><code>    delete_foreign_key_sql = 'ALTER TABLE %(table)s DROP CONSTRAINT %(constraint)s'</code></li>
<li class="missed"><code>    create_table_sql = 'CREATE TABLE %(table)s (%(columns)s)'</code></li>
<li class="missed"><code>    max_index_name_length = 63</code></li>
<li class="missed"><code>    drop_index_string = 'DROP INDEX %(index_name)s'</code></li>
<li class="missed"><code>    delete_column_string = 'ALTER TABLE %s DROP COLUMN %s CASCADE;'</code></li>
<li class="missed"><code>    create_primary_key_string = "ALTER TABLE %(table)s ADD CONSTRAINT %(constraint)s PRIMARY KEY (%(columns)s)"</code></li>
<li class="missed"><code>    delete_primary_key_sql = "ALTER TABLE %(table)s DROP CONSTRAINT %(constraint)s"</code></li>
<li class="missed"><code>    add_check_constraint_fragment = "ADD CONSTRAINT %(constraint)s CHECK (%(check)s)"</code></li>
<li class="missed"><code>    rename_table_sql = "ALTER TABLE %s RENAME TO %s;"</code></li>
<li class="missed"><code>    backend_name = None</code></li>
<li class="missed"><code>    default_schema_name = "public"</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    # Features</code></li>
<li class="missed"><code>    allows_combined_alters = True</code></li>
<li class="missed"><code>    supports_foreign_keys = True</code></li>
<li class="missed"><code>    has_check_constraints = True</code></li>
<li class="missed"><code>    has_booleans = True</code></li>
<li class="missed"><code>    raises_default_errors = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @cached_property</code></li>
<li class="ignored"><code>    def has_ddl_transactions(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Tests the database using feature detection to see if it has</code></li>
<li class="ignored"><code>        transactional DDL support.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        self._possibly_initialise()</code></li>
<li class="executed"><code>        connection = self._get_connection()</code></li>
<li class="executed"><code>        if hasattr(connection.features, "confirm") and not connection.features._confirmed:</code></li>
<li class="missed"><code>            connection.features.confirm()</code></li>
<li class="ignored"><code>        # Django 1.3's MySQLdb backend doesn't raise DatabaseError</code></li>
<li class="executed"><code>        exceptions = (DatabaseError, )</code></li>
<li class="executed"><code>        try:</code></li>
<li class="excluded"><code>            from MySQLdb import OperationalError</code></li>
<li class="missed"><code>            exceptions += (OperationalError, )</code></li>
<li class="executed"><code>        except ImportError:</code></li>
<li class="executed"><code>            pass</code></li>
<li class="ignored"><code>        # Now do the test</code></li>
<li class="executed"><code>        if getattr(connection.features, 'supports_transactions', True):</code></li>
<li class="executed"><code>            cursor = connection.cursor()</code></li>
<li class="executed"><code>            self.start_transaction()</code></li>
<li class="executed"><code>            cursor.execute('CREATE TABLE DDL_TRANSACTION_TEST (X INT)')</code></li>
<li class="executed"><code>            self.rollback_transaction()</code></li>
<li class="executed"><code>            try:</code></li>
<li class="executed"><code>                try:</code></li>
<li class="executed"><code>                    cursor.execute('CREATE TABLE DDL_TRANSACTION_TEST (X INT)')</code></li>
<li class="missed"><code>                except exceptions:</code></li>
<li class="missed"><code>                    return False</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="executed"><code>                    return True</code></li>
<li class="ignored"><code>            finally:</code></li>
<li class="executed"><code>                cursor.execute('DROP TABLE DDL_TRANSACTION_TEST')</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def __init__(self, db_alias):</code></li>
<li class="missed"><code>        self.debug = False</code></li>
<li class="missed"><code>        self.deferred_sql = []</code></li>
<li class="missed"><code>        self.dry_run = False</code></li>
<li class="missed"><code>        self.pending_transactions = 0</code></li>
<li class="missed"><code>        self.pending_create_signals = []</code></li>
<li class="missed"><code>        self.db_alias = db_alias</code></li>
<li class="missed"><code>        self._constraint_cache = {}</code></li>
<li class="missed"><code>        self._initialised = False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def lookup_constraint(self, db_name, table_name, column_name=None):</code></li>
<li class="ignored"><code>        """ return a set() of constraints for db_name.table_name.column_name """</code></li>
<li class="missed"><code>        def _lookup():</code></li>
<li class="missed"><code>            table = self._constraint_cache[db_name][table_name]</code></li>
<li class="missed"><code>            if table is INVALID:</code></li>
<li class="missed"><code>                raise INVALID</code></li>
<li class="missed"><code>            elif column_name is None:</code></li>
<li class="missed"><code>                return list(table.items())</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                return table[column_name]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            ret = _lookup()</code></li>
<li class="missed"><code>            return ret</code></li>
<li class="missed"><code>        except INVALID:</code></li>
<li class="missed"><code>            del self._constraint_cache[db_name][table_name]</code></li>
<li class="missed"><code>            self._fill_constraint_cache(db_name, table_name)</code></li>
<li class="missed"><code>        except KeyError:</code></li>
<li class="missed"><code>            if self._is_valid_cache(db_name, table_name):</code></li>
<li class="missed"><code>                return []</code></li>
<li class="missed"><code>            self._fill_constraint_cache(db_name, table_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return self.lookup_constraint(db_name, table_name, column_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _set_cache(self, table_name, column_name=None, value=INVALID):</code></li>
<li class="executed"><code>        db_name = self._get_setting('NAME')</code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            if column_name is not None:</code></li>
<li class="missed"><code>                self._constraint_cache[db_name][table_name][column_name] = value</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="executed"><code>                self._constraint_cache[db_name][table_name] = value</code></li>
<li class="executed"><code>        except (LookupError, TypeError):</code></li>
<li class="executed"><code>            pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _is_valid_cache(self, db_name, table_name):</code></li>
<li class="ignored"><code>        # we cache per-table so if the table is there it is valid</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            return self._constraint_cache[db_name][table_name] is not INVALID</code></li>
<li class="missed"><code>        except KeyError:</code></li>
<li class="missed"><code>            return False</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _is_multidb(self):</code></li>
<li class="executed"><code>        try:</code></li>
<li class="excluded"><code>            from django.db import connections</code></li>
<li class="executed"><code>            connections  # Prevents "unused import" warning</code></li>
<li class="missed"><code>        except ImportError:</code></li>
<li class="missed"><code>            return False</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            return True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_connection(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns a django connection for a given DB Alias</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self._is_multidb():</code></li>
<li class="excluded"><code>            from django.db import connections</code></li>
<li class="executed"><code>            return connections[self.db_alias]</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="excluded"><code>            from django.db import connection</code></li>
<li class="missed"><code>            return connection</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_setting(self, setting_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Allows code to get a setting (like, for example, STORAGE_ENGINE)</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        setting_name = setting_name.upper()</code></li>
<li class="executed"><code>        connection = self._get_connection()</code></li>
<li class="executed"><code>        if self._is_multidb():</code></li>
<li class="ignored"><code>            # Django 1.2 and above</code></li>
<li class="executed"><code>            return connection.settings_dict[setting_name]</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            # Django 1.1 and below</code></li>
<li class="missed"><code>            return getattr(settings, "DATABASE_%s" % setting_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _has_setting(self, setting_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Existence-checking version of _get_setting.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            self._get_setting(setting_name)</code></li>
<li class="missed"><code>        except (KeyError, AttributeError):</code></li>
<li class="missed"><code>            return False</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _get_schema_name(self):</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            return self._get_setting('schema')</code></li>
<li class="missed"><code>        except (KeyError, AttributeError):</code></li>
<li class="missed"><code>            return self.default_schema_name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _possibly_initialise(self):</code></li>
<li class="executed"><code>        if not self._initialised:</code></li>
<li class="executed"><code>            self.connection_init()</code></li>
<li class="executed"><code>            self._initialised = True</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def connection_init(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Run before any SQL to let database-specific config be sent as a command,</code></li>
<li class="ignored"><code>        e.g. which storage engine (MySQL) or transaction serialisability level.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def quote_name(self, name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Uses the database backend to quote the given table/column name.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        return self._get_connection().ops.quote_name(name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _print_sql_error(self, e, sql, params=[]):</code></li>
<li class="missed"><code>        print('FATAL ERROR - The following SQL query failed: %s' % sql, file=sys.stderr)</code></li>
<li class="missed"><code>        print('The error was: %s' % e, file=sys.stderr)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def execute(self, sql, params=[], print_all_errors=True):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Executes the given SQL statement, with optional parameters.</code></li>
<li class="ignored"><code>        If the instance's debug attribute is True, prints out what it executes.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self._possibly_initialise()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        cursor = self._get_connection().cursor()</code></li>
<li class="executed"><code>        if self.debug:</code></li>
<li class="missed"><code>            print("   = %s" % sql, params)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            return []</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        get_logger().debug(text_type('execute "%s" with params "%s"' % (sql, params)))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            cursor.execute(sql, params)</code></li>
<li class="missed"><code>        except DatabaseError as e:</code></li>
<li class="missed"><code>            if print_all_errors:</code></li>
<li class="missed"><code>                self._print_sql_error(e, sql, params)</code></li>
<li class="missed"><code>            raise</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            return cursor.fetchall()</code></li>
<li class="executed"><code>        except:</code></li>
<li class="executed"><code>            return []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def execute_many(self, sql, regex=r"(?mx) ([^';]* (?:'[^']*'[^';]*)*)", comment_regex=r"(?mx) (?:^\s*$)|(?:--.*$)"):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Takes a SQL file and executes it as many separate statements.</code></li>
<li class="ignored"><code>        (Some backends, such as Postgres, don't work otherwise.)</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # Be warned: This function is full of dark magic. Make sure you really</code></li>
<li class="ignored"><code>        # know regexes before trying to edit it.</code></li>
<li class="ignored"><code>        # First, strip comments</code></li>
<li class="missed"><code>        sql = "\n".join([x.strip().replace("%", "%%") for x in re.split(comment_regex, sql) if x.strip()])</code></li>
<li class="ignored"><code>        # Now execute each statement</code></li>
<li class="missed"><code>        for st in re.split(regex, sql)[1:][::2]:</code></li>
<li class="missed"><code>            self.execute(st)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def add_deferred_sql(self, sql):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Add a SQL statement to the deferred list, that won't be executed until</code></li>
<li class="ignored"><code>        this instance's execute_deferred_sql method is run.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        self.deferred_sql.append(sql)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def execute_deferred_sql(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Executes all deferred SQL, resetting the deferred_sql list</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        for sql in self.deferred_sql:</code></li>
<li class="executed"><code>            self.execute(sql)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self.deferred_sql = []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def clear_deferred_sql(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Resets the deferred_sql list to empty.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        self.deferred_sql = []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def clear_run_data(self, pending_creates = None):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Resets variables to how they should be before a run. Used for dry runs.</code></li>
<li class="ignored"><code>        If you want, pass in an old panding_creates to reset to.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        self.clear_deferred_sql()</code></li>
<li class="missed"><code>        self.pending_create_signals = pending_creates or []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def get_pending_creates(self):</code></li>
<li class="missed"><code>        return self.pending_create_signals</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def create_table(self, table_name, fields):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates the table 'table_name'. 'fields' is a tuple of fields,</code></li>
<li class="ignored"><code>        each repsented by a 2-part tuple of field name and a</code></li>
<li class="ignored"><code>        django.db.models.fields.Field object</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if len(table_name) &gt; 63:</code></li>
<li class="missed"><code>            print("   ! WARNING: You have a table name longer than 63 characters; this will not fully work on PostgreSQL or MySQL.")</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # avoid default values in CREATE TABLE statements (#925)</code></li>
<li class="executed"><code>        for field_name, field in fields:</code></li>
<li class="executed"><code>            field._suppress_default = True</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        columns = [</code></li>
<li class="ignored"><code>            self.column_sql(table_name, field_name, field)</code></li>
<li class="ignored"><code>            for field_name, field in fields</code></li>
<li class="ignored"><code>        ]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self.execute(self.create_table_sql % {</code></li>
<li class="ignored"><code>            "table": self.quote_name(table_name),</code></li>
<li class="ignored"><code>            "columns": ', '.join([col for col in columns if col]),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    add_table = alias('create_table')  # Alias for consistency's sake</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def rename_table(self, old_table_name, table_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Renames the table 'old_table_name' to 'table_name'.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if old_table_name == table_name:</code></li>
<li class="ignored"><code>            # Short-circuit out.</code></li>
<li class="missed"><code>            return</code></li>
<li class="missed"><code>        params = (self.quote_name(old_table_name), self.quote_name(table_name))</code></li>
<li class="missed"><code>        self.execute(self.rename_table_sql % params)</code></li>
<li class="ignored"><code>        # Invalidate the not-yet-indexed table</code></li>
<li class="missed"><code>        self._set_cache(table_name, value=INVALID)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="missed"><code>    def delete_table(self, table_name, cascade=True):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes the table 'table_name'.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        params = (self.quote_name(table_name), )</code></li>
<li class="executed"><code>        if cascade:</code></li>
<li class="executed"><code>            self.execute('DROP TABLE %s CASCADE;' % params)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            self.execute('DROP TABLE %s;' % params)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    drop_table = alias('delete_table')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def clear_table(self, table_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes all rows from 'table_name'.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        params = (self.quote_name(table_name), )</code></li>
<li class="missed"><code>        self.execute('DELETE FROM %s;' % params)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="missed"><code>    def add_column(self, table_name, name, field, keep_default=True):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Adds the column 'name' to the table 'table_name'.</code></li>
<li class="ignored"><code>        Uses the 'field' paramater, a django.db.models.fields.Field instance,</code></li>
<li class="ignored"><code>        to generate the necessary sql</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        @param table_name: The name of the table to add the column to</code></li>
<li class="ignored"><code>        @param name: The name of the column to add</code></li>
<li class="ignored"><code>        @param field: The field to use</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        sql = self.column_sql(table_name, name, field)</code></li>
<li class="missed"><code>        if sql:</code></li>
<li class="missed"><code>            params = (</code></li>
<li class="ignored"><code>                self.quote_name(table_name),</code></li>
<li class="ignored"><code>                sql,</code></li>
<li class="ignored"><code>            )</code></li>
<li class="missed"><code>            sql = self.add_column_string % params</code></li>
<li class="missed"><code>            self.execute(sql)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Now, drop the default if we need to</code></li>
<li class="missed"><code>            if field.default is not None:</code></li>
<li class="missed"><code>                field.default = NOT_PROVIDED</code></li>
<li class="missed"><code>                self.alter_column(table_name, name, field, explicit_name=False, ignore_constraints=True)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _db_type_for_alter_column(self, field):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Returns a field's type suitable for ALTER COLUMN.</code></li>
<li class="ignored"><code>        By default it just returns field.db_type().</code></li>
<li class="ignored"><code>        To be overriden by backend specific subclasses</code></li>
<li class="ignored"><code>        @param field: The field to generate type for</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        try:</code></li>
<li class="missed"><code>            return field.db_type(connection=self._get_connection())</code></li>
<li class="missed"><code>        except TypeError:</code></li>
<li class="missed"><code>            return field.db_type()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _alter_add_column_mods(self, field, name, params, sqls):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Subcommand of alter_column that modifies column definitions beyond</code></li>
<li class="ignored"><code>        the type string -- e.g. adding constraints where they cannot be specified</code></li>
<li class="ignored"><code>        as part of the type (overrideable)</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _alter_set_defaults(self, field, name, params, sqls):</code></li>
<li class="ignored"><code>        "Subcommand of alter_column that sets default values (overrideable)"</code></li>
<li class="ignored"><code>        # Historically, we used to set defaults here.</code></li>
<li class="ignored"><code>        # But since South 0.8, we don't ever set defaults on alter-column -- we only</code></li>
<li class="ignored"><code>        # use database-level defaults as scaffolding when adding columns.</code></li>
<li class="ignored"><code>        # However, we still sometimes need to remove defaults in alter-column.</code></li>
<li class="missed"><code>        sqls.append(('ALTER COLUMN %s DROP DEFAULT' % (self.quote_name(name),), []))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _update_nulls_to_default(self, params, field):</code></li>
<li class="ignored"><code>        "Subcommand of alter_column that updates nulls to default value (overrideable)"</code></li>
<li class="missed"><code>        default = field.get_db_prep_save(field.get_default(), connection=self._get_connection())</code></li>
<li class="missed"><code>        self.execute('UPDATE %(table_name)s SET %(column)s=%%s WHERE %(column)s IS NULL' % params, [default])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="missed"><code>    def alter_column(self, table_name, name, field, explicit_name=True, ignore_constraints=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Alters the given column name so it will match the given field.</code></li>
<li class="ignored"><code>        Note that conversion between the two by the database must be possible.</code></li>
<li class="ignored"><code>        Will not automatically add _id by default; to have this behavour, pass</code></li>
<li class="ignored"><code>        explicit_name=False.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        @param table_name: The name of the table to add the column to</code></li>
<li class="ignored"><code>        @param name: The name of the column to alter</code></li>
<li class="ignored"><code>        @param field: The new field definition to use</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            if self.debug:</code></li>
<li class="missed"><code>                print('   - no dry run output for alter_column() due to dynamic DDL, sorry')</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # hook for the field to do any resolution prior to it's attributes being queried</code></li>
<li class="missed"><code>        if hasattr(field, 'south_init'):</code></li>
<li class="missed"><code>            field.south_init()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Add _id or whatever if we need to</code></li>
<li class="missed"><code>        field.set_attributes_from_name(name)</code></li>
<li class="missed"><code>        if not explicit_name:</code></li>
<li class="missed"><code>            name = field.column</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            field.column = name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not ignore_constraints:</code></li>
<li class="ignored"><code>            # Drop all check constraints. Note that constraints will be added back</code></li>
<li class="ignored"><code>            # with self.alter_string_set_type and self.alter_string_drop_null.</code></li>
<li class="missed"><code>            if self.has_check_constraints:</code></li>
<li class="missed"><code>                check_constraints = self._constraints_affecting_columns(table_name, [name], "CHECK")</code></li>
<li class="missed"><code>                for constraint in check_constraints:</code></li>
<li class="missed"><code>                    self.execute(self.delete_check_sql % {</code></li>
<li class="ignored"><code>                        'table': self.quote_name(table_name),</code></li>
<li class="ignored"><code>                        'constraint': self.quote_name(constraint),</code></li>
<li class="ignored"><code>                    })</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Drop all foreign key constraints</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                self.delete_foreign_key(table_name, name)</code></li>
<li class="missed"><code>            except ValueError:</code></li>
<li class="ignored"><code>                # There weren't any</code></li>
<li class="missed"><code>                pass</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # First, change the type</code></li>
<li class="missed"><code>        params = {</code></li>
<li class="ignored"><code>            "column": self.quote_name(name),</code></li>
<li class="ignored"><code>            "type": self._db_type_for_alter_column(field),</code></li>
<li class="ignored"><code>            "table_name": self.quote_name(table_name)</code></li>
<li class="ignored"><code>        }</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # SQLs is a list of (SQL, values) pairs.</code></li>
<li class="missed"><code>        sqls = []</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Only alter the column if it has a type (Geometry ones sometimes don't)</code></li>
<li class="missed"><code>        if params["type"] is not None:</code></li>
<li class="missed"><code>            sqls.append((self.alter_string_set_type % params, []))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Add any field- and backend- specific modifications</code></li>
<li class="missed"><code>        self._alter_add_column_mods(field, name, params, sqls)</code></li>
<li class="ignored"><code>        # Next, nullity</code></li>
<li class="missed"><code>        if field.null or field.has_default():</code></li>
<li class="missed"><code>            sqls.append((self.alter_string_set_null % params, []))</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            sqls.append((self.alter_string_drop_null % params, []))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Do defaults</code></li>
<li class="missed"><code>        self._alter_set_defaults(field, name, params, sqls)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Actually change the column (step 1 -- Nullity may need to be fixed)</code></li>
<li class="missed"><code>        if self.allows_combined_alters:</code></li>
<li class="missed"><code>            sqls, values = zip(*sqls)</code></li>
<li class="missed"><code>            self.execute(</code></li>
<li class="ignored"><code>                "ALTER TABLE %s %s;" % (self.quote_name(table_name), ", ".join(sqls)),</code></li>
<li class="ignored"><code>                flatten(values),</code></li>
<li class="ignored"><code>            )</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="ignored"><code>            # Databases like e.g. MySQL don't like more than one alter at once.</code></li>
<li class="missed"><code>            for sql, values in sqls:</code></li>
<li class="missed"><code>                self.execute("ALTER TABLE %s %s;" % (self.quote_name(table_name), sql), values)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not field.null and field.has_default():</code></li>
<li class="ignored"><code>            # Final fixes</code></li>
<li class="missed"><code>            self._update_nulls_to_default(params, field)</code></li>
<li class="missed"><code>            self.execute("ALTER TABLE %s %s;" % (self.quote_name(table_name), self.alter_string_drop_null % params), [])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not ignore_constraints:</code></li>
<li class="ignored"><code>            # Add back FK constraints if needed</code></li>
<li class="missed"><code>            if field.rel and self.supports_foreign_keys:</code></li>
<li class="missed"><code>                self.execute(</code></li>
<li class="ignored"><code>                    self.foreign_key_sql(</code></li>
<li class="ignored"><code>                        table_name,</code></li>
<li class="ignored"><code>                        field.column,</code></li>
<li class="ignored"><code>                        field.rel.to._meta.db_table,</code></li>
<li class="ignored"><code>                        field.rel.to._meta.get_field(field.rel.field_name).column</code></li>
<li class="ignored"><code>                    )</code></li>
<li class="ignored"><code>                )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _fill_constraint_cache(self, db_name, table_name):</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        schema = self._get_schema_name()</code></li>
<li class="missed"><code>        ifsc_tables = ["constraint_column_usage", "key_column_usage"]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        self._constraint_cache.setdefault(db_name, {})</code></li>
<li class="missed"><code>        self._constraint_cache[db_name][table_name] = {}</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for ifsc_table in ifsc_tables:</code></li>
<li class="missed"><code>            rows = self.execute("""</code></li>
<li class="ignored"><code>                SELECT kc.constraint_name, kc.column_name, c.constraint_type</code></li>
<li class="ignored"><code>                FROM information_schema.%s AS kc</code></li>
<li class="ignored"><code>                JOIN information_schema.table_constraints AS c ON</code></li>
<li class="ignored"><code>                    kc.table_schema = c.table_schema AND</code></li>
<li class="ignored"><code>                    kc.table_name = c.table_name AND</code></li>
<li class="ignored"><code>                    kc.constraint_name = c.constraint_name</code></li>
<li class="ignored"><code>                WHERE</code></li>
<li class="ignored"><code>                    kc.table_schema = %%s AND</code></li>
<li class="ignored"><code>                    kc.table_name = %%s</code></li>
<li class="ignored"><code>            """ % ifsc_table, [schema, table_name])</code></li>
<li class="missed"><code>            for constraint, column, kind in rows:</code></li>
<li class="missed"><code>                self._constraint_cache[db_name][table_name].setdefault(column, set())</code></li>
<li class="missed"><code>                self._constraint_cache[db_name][table_name][column].add((kind, constraint))</code></li>
<li class="missed"><code>        return</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _constraints_affecting_columns(self, table_name, columns, type="UNIQUE"):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Gets the names of the constraints affecting the given columns.</code></li>
<li class="ignored"><code>        If columns is None, returns all constraints of the type on the table.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            raise DryRunError("Cannot get constraints for columns.")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if columns is not None:</code></li>
<li class="missed"><code>            columns = set(map(lambda s: s.lower(), columns))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        db_name = self._get_setting('NAME')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cnames = {}</code></li>
<li class="missed"><code>        for col, constraints in self.lookup_constraint(db_name, table_name):</code></li>
<li class="missed"><code>            for kind, cname in constraints:</code></li>
<li class="missed"><code>                if kind == type:</code></li>
<li class="missed"><code>                    cnames.setdefault(cname, set())</code></li>
<li class="missed"><code>                    cnames[cname].add(col.lower())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for cname, cols in cnames.items():</code></li>
<li class="missed"><code>            if cols == columns or columns is None:</code></li>
<li class="missed"><code>                yield cname</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def create_unique(self, table_name, columns):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates a UNIQUE constraint on the columns on the given table.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not isinstance(columns, (list, tuple)):</code></li>
<li class="missed"><code>            columns = [columns]</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        name = self.create_index_name(table_name, columns, suffix="_uniq")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        cols = ", ".join(map(self.quote_name, columns))</code></li>
<li class="missed"><code>        self.execute("ALTER TABLE %s ADD CONSTRAINT %s UNIQUE (%s)" % (</code></li>
<li class="ignored"><code>            self.quote_name(table_name),</code></li>
<li class="ignored"><code>            self.quote_name(name),</code></li>
<li class="ignored"><code>            cols,</code></li>
<li class="ignored"><code>        ))</code></li>
<li class="missed"><code>        return name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def delete_unique(self, table_name, columns):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes a UNIQUE constraint on precisely the columns on the given table.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if not isinstance(columns, (list, tuple)):</code></li>
<li class="missed"><code>            columns = [columns]</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Dry runs mean we can't do anything.</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            if self.debug:</code></li>
<li class="missed"><code>                print('   - no dry run output for delete_unique_column() due to dynamic DDL, sorry')</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        constraints = list(self._constraints_affecting_columns(table_name, columns))</code></li>
<li class="missed"><code>        if not constraints:</code></li>
<li class="missed"><code>            raise ValueError("Cannot find a UNIQUE constraint on table %s, columns %r" % (table_name, columns))</code></li>
<li class="missed"><code>        for constraint in constraints:</code></li>
<li class="missed"><code>            self.execute(self.delete_unique_sql % (</code></li>
<li class="ignored"><code>                self.quote_name(table_name),</code></li>
<li class="ignored"><code>                self.quote_name(constraint),</code></li>
<li class="ignored"><code>            ))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def column_sql(self, table_name, field_name, field, tablespace='', with_name=True, field_prepared=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates the SQL snippet for a column. Used by add_column and add_table.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If the field hasn't already been told its attribute name, do so.</code></li>
<li class="executed"><code>        if not field_prepared:</code></li>
<li class="executed"><code>            field.set_attributes_from_name(field_name)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # hook for the field to do any resolution prior to it's attributes being queried</code></li>
<li class="executed"><code>        if hasattr(field, 'south_init'):</code></li>
<li class="missed"><code>            field.south_init()</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Possible hook to fiddle with the fields (e.g. defaults &amp; TEXT on MySQL)</code></li>
<li class="executed"><code>        field = self._field_sanity(field)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            sql = field.db_type(connection=self._get_connection())</code></li>
<li class="missed"><code>        except TypeError:</code></li>
<li class="missed"><code>            sql = field.db_type()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if sql:</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>            # Some callers, like the sqlite stuff, just want the extended type.</code></li>
<li class="executed"><code>            if with_name:</code></li>
<li class="executed"><code>                field_output = [self.quote_name(field.column), sql]</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                field_output = [sql]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            field_output.append('%sNULL' % (not field.null and 'NOT ' or ''))</code></li>
<li class="executed"><code>            if field.primary_key:</code></li>
<li class="executed"><code>                field_output.append('PRIMARY KEY')</code></li>
<li class="executed"><code>            elif field.unique:</code></li>
<li class="ignored"><code>                # Just use UNIQUE (no indexes any more, we have delete_unique)</code></li>
<li class="missed"><code>                field_output.append('UNIQUE')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            tablespace = field.db_tablespace or tablespace</code></li>
<li class="executed"><code>            if tablespace and getattr(self._get_connection().features, "supports_tablespaces", False) and field.unique:</code></li>
<li class="ignored"><code>                # We must specify the index tablespace inline, because we</code></li>
<li class="ignored"><code>                # won't be generating a CREATE INDEX statement for this field.</code></li>
<li class="missed"><code>                field_output.append(self._get_connection().ops.tablespace_sql(tablespace, inline=True))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            sql = ' '.join(field_output)</code></li>
<li class="executed"><code>            sqlparams = ()</code></li>
<li class="ignored"><code>            # if the field is "NOT NULL" and a default value is provided, create the column with it</code></li>
<li class="ignored"><code>            # this allows the addition of a NOT NULL field to a table with existing rows</code></li>
<li class="executed"><code>            if not getattr(field, '_suppress_default', False):</code></li>
<li class="missed"><code>                if field.has_default():</code></li>
<li class="missed"><code>                    default = field.get_default()</code></li>
<li class="ignored"><code>                    # If the default is actually None, don't add a default term</code></li>
<li class="missed"><code>                    if default is not None:</code></li>
<li class="ignored"><code>                        # If the default is a callable, then call it!</code></li>
<li class="missed"><code>                        if callable(default):</code></li>
<li class="missed"><code>                            default = default()</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>                        default = field.get_db_prep_save(default, connection=self._get_connection())</code></li>
<li class="missed"><code>                        default = self._default_value_workaround(default)</code></li>
<li class="ignored"><code>                        # Now do some very cheap quoting. TODO: Redesign return values to avoid this.</code></li>
<li class="missed"><code>                        if isinstance(default, string_types):</code></li>
<li class="missed"><code>                            default = "'%s'" % default.replace("'", "''")</code></li>
<li class="ignored"><code>                        # Escape any % signs in the output (bug #317)</code></li>
<li class="missed"><code>                        if isinstance(default, string_types):</code></li>
<li class="missed"><code>                            default = default.replace("%", "%%")</code></li>
<li class="ignored"><code>                        # Add it in</code></li>
<li class="missed"><code>                        sql += " DEFAULT %s"</code></li>
<li class="missed"><code>                        sqlparams = (default)</code></li>
<li class="missed"><code>                elif (not field.null and field.blank) or (field.get_default() == ''):</code></li>
<li class="missed"><code>                    if field.empty_strings_allowed and self._get_connection().features.interprets_empty_strings_as_nulls:</code></li>
<li class="missed"><code>                        sql += " DEFAULT ''"</code></li>
<li class="ignored"><code>                    # Error here would be nice, but doesn't seem to play fair.</code></li>
<li class="ignored"><code>                    #else:</code></li>
<li class="ignored"><code>                    #    raise ValueError("Attempting to add a non null column that isn't character based without an explicit default value.")</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            if field.rel and self.supports_foreign_keys:</code></li>
<li class="executed"><code>                self.add_deferred_sql(</code></li>
<li class="ignored"><code>                    self.foreign_key_sql(</code></li>
<li class="ignored"><code>                        table_name,</code></li>
<li class="ignored"><code>                        field.column,</code></li>
<li class="ignored"><code>                        field.rel.to._meta.db_table,</code></li>
<li class="ignored"><code>                        field.rel.to._meta.get_field(field.rel.field_name).column</code></li>
<li class="ignored"><code>                    )</code></li>
<li class="ignored"><code>                )</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Things like the contrib.gis module fields have this in 1.1 and below</code></li>
<li class="executed"><code>        if hasattr(field, 'post_create_sql'):</code></li>
<li class="missed"><code>            for stmt in field.post_create_sql(no_style(), table_name):</code></li>
<li class="missed"><code>                self.add_deferred_sql(stmt)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # In 1.2 and above, you have to ask the DatabaseCreation stuff for it.</code></li>
<li class="ignored"><code>        # This also creates normal indexes in 1.1.</code></li>
<li class="executed"><code>        if hasattr(self._get_connection().creation, "sql_indexes_for_field"):</code></li>
<li class="ignored"><code>            # Make a fake model to pass in, with only db_table</code></li>
<li class="executed"><code>            model = self.mock_model("FakeModelForGISCreation", table_name)</code></li>
<li class="executed"><code>            for stmt in self._get_connection().creation.sql_indexes_for_field(model, field, no_style()):</code></li>
<li class="executed"><code>                self.add_deferred_sql(stmt)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if sql:</code></li>
<li class="executed"><code>            return sql % sqlparams</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return None</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _field_sanity(self, field):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Placeholder for DBMS-specific field alterations (some combos aren't valid,</code></li>
<li class="ignored"><code>        e.g. DEFAULT and TEXT on MySQL)</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        return field</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _default_value_workaround(self, value):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        DBMS-specific value alterations (this really works around</code></li>
<li class="ignored"><code>        missing functionality in Django backends)</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if isinstance(value, bool) and not self.has_booleans:</code></li>
<li class="missed"><code>            return int(value)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            return value</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def foreign_key_sql(self, from_table_name, from_column_name, to_table_name, to_column_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Generates a full SQL statement to add a foreign key constraint</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        constraint_name = '%s_refs_%s_%s' % (from_column_name, to_column_name, self._digest(from_table_name, to_table_name))</code></li>
<li class="executed"><code>        return 'ALTER TABLE %s ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s)%s;' % (</code></li>
<li class="ignored"><code>            self.quote_name(from_table_name),</code></li>
<li class="ignored"><code>            self.quote_name(self.shorten_name(constraint_name)),</code></li>
<li class="ignored"><code>            self.quote_name(from_column_name),</code></li>
<li class="ignored"><code>            self.quote_name(to_table_name),</code></li>
<li class="ignored"><code>            self.quote_name(to_column_name),</code></li>
<li class="ignored"><code>            self._get_connection().ops.deferrable_sql()  # Django knows this</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def delete_foreign_key(self, table_name, column):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Drop a foreign key constraint</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            if self.debug:</code></li>
<li class="missed"><code>                print('   - no dry run output for delete_foreign_key() due to dynamic DDL, sorry')</code></li>
<li class="missed"><code>            return  # We can't look at the DB to get the constraints</code></li>
<li class="missed"><code>        constraints = self._find_foreign_constraints(table_name, column)</code></li>
<li class="missed"><code>        if not constraints:</code></li>
<li class="missed"><code>            raise ValueError("Cannot find a FOREIGN KEY constraint on table %s, column %s" % (table_name, column))</code></li>
<li class="missed"><code>        for constraint_name in constraints:</code></li>
<li class="missed"><code>            self.execute(self.delete_foreign_key_sql % {</code></li>
<li class="ignored"><code>                "table": self.quote_name(table_name),</code></li>
<li class="ignored"><code>                "constraint": self.quote_name(constraint_name),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    drop_foreign_key = alias('delete_foreign_key')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _find_foreign_constraints(self, table_name, column_name=None):</code></li>
<li class="missed"><code>        constraints = self._constraints_affecting_columns(</code></li>
<li class="ignored"><code>                            table_name, [column_name], "FOREIGN KEY")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        primary_key_columns = self._find_primary_key_columns(table_name)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        if len(primary_key_columns) &gt; 1:</code></li>
<li class="ignored"><code>            # Composite primary keys cannot be referenced by a foreign key</code></li>
<li class="missed"><code>            return list(constraints)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            primary_key_columns.add(column_name)</code></li>
<li class="missed"><code>            recursive_constraints = set(self._constraints_affecting_columns(</code></li>
<li class="ignored"><code>                                table_name, primary_key_columns, "FOREIGN KEY"))</code></li>
<li class="missed"><code>            return list(recursive_constraints.union(constraints))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _digest(self, *args):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Use django.db.backends.creation.BaseDatabaseCreation._digest</code></li>
<li class="ignored"><code>        to create index name in Django style. An evil hack :(</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if not hasattr(self, '_django_db_creation'):</code></li>
<li class="executed"><code>            self._django_db_creation = BaseDatabaseCreation(self._get_connection())</code></li>
<li class="executed"><code>        return self._django_db_creation._digest(*args)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def shorten_name(self, name):</code></li>
<li class="executed"><code>        return truncate_name(name, self._get_connection().ops.max_name_length())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def create_index_name(self, table_name, column_names, suffix=""):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Generate a unique name for the index</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If there is just one column in the index, use a default algorithm from Django</code></li>
<li class="missed"><code>        if len(column_names) == 1 and not suffix:</code></li>
<li class="missed"><code>            try:</code></li>
<li class="missed"><code>                _hash = self._digest([column_names[0]])</code></li>
<li class="missed"><code>            except TypeError:</code></li>
<li class="ignored"><code>                # Django &lt; 1.5 backward compatibility.</code></li>
<li class="missed"><code>                _hash = self._digest(column_names[0])</code></li>
<li class="missed"><code>            return self.shorten_name(</code></li>
<li class="ignored"><code>                '%s_%s' % (table_name, _hash),</code></li>
<li class="ignored"><code>            )</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # Else generate the name for the index by South</code></li>
<li class="missed"><code>        table_name = table_name.replace('"', '').replace('.', '_')</code></li>
<li class="missed"><code>        index_unique_name = '_%x' % abs(hash((table_name, ','.join(column_names))))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # If the index name is too long, truncate it</code></li>
<li class="missed"><code>        index_name = ('%s_%s%s%s' % (table_name, column_names[0], index_unique_name, suffix)).replace('"', '').replace('.', '_')</code></li>
<li class="missed"><code>        if len(index_name) &gt; self.max_index_name_length:</code></li>
<li class="missed"><code>            part = ('_%s%s%s' % (column_names[0], index_unique_name, suffix))</code></li>
<li class="missed"><code>            index_name = '%s%s' % (table_name[:(self.max_index_name_length - len(part))], part)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return index_name</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def create_index_sql(self, table_name, column_names, unique=False, db_tablespace=''):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Generates a create index statement on 'table_name' for a list of 'column_names'</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not column_names:</code></li>
<li class="missed"><code>            print("No column names supplied on which to create an index")</code></li>
<li class="missed"><code>            return ''</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        connection = self._get_connection()</code></li>
<li class="missed"><code>        if db_tablespace and connection.features.supports_tablespaces:</code></li>
<li class="missed"><code>            tablespace_sql = ' ' + connection.ops.tablespace_sql(db_tablespace)</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="missed"><code>            tablespace_sql = ''</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        index_name = self.create_index_name(table_name, column_names)</code></li>
<li class="missed"><code>        return 'CREATE %sINDEX %s ON %s (%s)%s;' % (</code></li>
<li class="ignored"><code>            unique and 'UNIQUE ' or '',</code></li>
<li class="ignored"><code>            self.quote_name(index_name),</code></li>
<li class="ignored"><code>            self.quote_name(table_name),</code></li>
<li class="ignored"><code>            ','.join([self.quote_name(field) for field in column_names]),</code></li>
<li class="ignored"><code>            tablespace_sql</code></li>
<li class="ignored"><code>        )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="missed"><code>    def create_index(self, table_name, column_names, unique=False, db_tablespace=''):</code></li>
<li class="ignored"><code>        """ Executes a create index statement """</code></li>
<li class="missed"><code>        sql = self.create_index_sql(table_name, column_names, unique, db_tablespace)</code></li>
<li class="missed"><code>        self.execute(sql)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="missed"><code>    def delete_index(self, table_name, column_names, db_tablespace=''):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes an index created with create_index.</code></li>
<li class="ignored"><code>        This is possible using only columns due to the deterministic</code></li>
<li class="ignored"><code>        index naming function which relies on column names.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if isinstance(column_names, string_types):</code></li>
<li class="missed"><code>            column_names = [column_names]</code></li>
<li class="missed"><code>        name = self.create_index_name(table_name, column_names)</code></li>
<li class="missed"><code>        sql = self.drop_index_string % {</code></li>
<li class="ignored"><code>            "index_name": self.quote_name(name),</code></li>
<li class="ignored"><code>            "table_name": self.quote_name(table_name),</code></li>
<li class="ignored"><code>        }</code></li>
<li class="missed"><code>        self.execute(sql)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    drop_index = alias('delete_index')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @delete_column_constraints</code></li>
<li class="ignored"><code>    def delete_column(self, table_name, name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Deletes the column 'column_name' from the table 'table_name'.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        params = (self.quote_name(table_name), self.quote_name(name))</code></li>
<li class="missed"><code>        self.execute(self.delete_column_string % params, [])</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    drop_column = alias('delete_column')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def rename_column(self, table_name, old, new):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Renames the column 'old' from the table 'table_name' to 'new'.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        raise NotImplementedError("rename_column has no generic SQL syntax")</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def delete_primary_key(self, table_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Drops the old primary key.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        # Dry runs mean we can't do anything.</code></li>
<li class="missed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            if self.debug:</code></li>
<li class="missed"><code>                print('   - no dry run output for delete_primary_key() due to dynamic DDL, sorry')</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        constraints = list(self._constraints_affecting_columns(table_name, None, type="PRIMARY KEY"))</code></li>
<li class="missed"><code>        if not constraints:</code></li>
<li class="missed"><code>            raise ValueError("Cannot find a PRIMARY KEY constraint on table %s" % (table_name,))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        for constraint in constraints:</code></li>
<li class="missed"><code>            self.execute(self.delete_primary_key_sql % {</code></li>
<li class="ignored"><code>                "table": self.quote_name(table_name),</code></li>
<li class="ignored"><code>                "constraint": self.quote_name(constraint),</code></li>
<li class="ignored"><code>            })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    drop_primary_key = alias('delete_primary_key')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    @invalidate_table_constraints</code></li>
<li class="ignored"><code>    def create_primary_key(self, table_name, columns):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Creates a new primary key on the specified columns.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not isinstance(columns, (list, tuple)):</code></li>
<li class="missed"><code>            columns = [columns]</code></li>
<li class="missed"><code>        self.execute(self.create_primary_key_string % {</code></li>
<li class="ignored"><code>            "table": self.quote_name(table_name),</code></li>
<li class="ignored"><code>            "constraint": self.quote_name(table_name + "_pkey"),</code></li>
<li class="ignored"><code>            "columns": ", ".join(map(self.quote_name, columns)),</code></li>
<li class="ignored"><code>        })</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _find_primary_key_columns(self, table_name):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Find all columns of the primary key of the specified table</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        db_name = self._get_setting('NAME')</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        primary_key_columns = set()</code></li>
<li class="missed"><code>        for col, constraints in self.lookup_constraint(db_name, table_name):</code></li>
<li class="missed"><code>            for kind, cname in constraints:</code></li>
<li class="missed"><code>                if kind == 'PRIMARY KEY':</code></li>
<li class="missed"><code>                    primary_key_columns.add(col.lower())</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return primary_key_columns</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def start_transaction(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Makes sure the following commands are inside a transaction.</code></li>
<li class="ignored"><code>        Must be followed by a (commit|rollback)_transaction call.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            self.pending_transactions += 1</code></li>
<li class="executed"><code>        transaction.commit_unless_managed(using=self.db_alias)</code></li>
<li class="executed"><code>        transaction.enter_transaction_management(using=self.db_alias)</code></li>
<li class="executed"><code>        transaction.managed(True, using=self.db_alias)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def commit_transaction(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Commits the current transaction.</code></li>
<li class="ignored"><code>        Must be preceded by a start_transaction call.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            return</code></li>
<li class="executed"><code>        transaction.commit(using=self.db_alias)</code></li>
<li class="executed"><code>        transaction.leave_transaction_management(using=self.db_alias)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def rollback_transaction(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Rolls back the current transaction.</code></li>
<li class="ignored"><code>        Must be preceded by a start_transaction call.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        if self.dry_run:</code></li>
<li class="missed"><code>            self.pending_transactions -= 1</code></li>
<li class="executed"><code>        transaction.rollback(using=self.db_alias)</code></li>
<li class="executed"><code>        transaction.leave_transaction_management(using=self.db_alias)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def rollback_transactions_dry_run(self):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Rolls back all pending_transactions during this dry run.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        if not self.dry_run:</code></li>
<li class="missed"><code>            return</code></li>
<li class="missed"><code>        while self.pending_transactions &gt; 0:</code></li>
<li class="missed"><code>            self.rollback_transaction()</code></li>
<li class="missed"><code>        if transaction.is_dirty(using=self.db_alias):</code></li>
<li class="ignored"><code>            # Force an exception, if we're still in a dirty transaction.</code></li>
<li class="ignored"><code>            # This means we are missing a COMMIT/ROLLBACK.</code></li>
<li class="missed"><code>            transaction.leave_transaction_management(using=self.db_alias)</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def send_create_signal(self, app_label, model_names):</code></li>
<li class="executed"><code>        self.pending_create_signals.append((app_label, model_names))</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def send_pending_create_signals(self, verbosity=0, interactive=False):</code></li>
<li class="ignored"><code>        # Group app_labels together</code></li>
<li class="executed"><code>        signals = SortedDict()</code></li>
<li class="executed"><code>        for (app_label, model_names) in self.pending_create_signals:</code></li>
<li class="executed"><code>            try:</code></li>
<li class="executed"><code>                signals[app_label].extend(model_names)</code></li>
<li class="executed"><code>            except KeyError:</code></li>
<li class="executed"><code>                signals[app_label] = list(model_names)</code></li>
<li class="ignored"><code>        # Send only one signal per app.</code></li>
<li class="executed"><code>        for (app_label, model_names) in signals.items():</code></li>
<li class="executed"><code>            self.really_send_create_signal(app_label, list(set(model_names)),</code></li>
<li class="ignored"><code>                                           verbosity=verbosity,</code></li>
<li class="ignored"><code>                                           interactive=interactive)</code></li>
<li class="executed"><code>        self.pending_create_signals = []</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def really_send_create_signal(self, app_label, model_names,</code></li>
<li class="ignored"><code>                                  verbosity=0, interactive=False):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Sends a post_syncdb signal for the model specified.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If the model is not found (perhaps it's been deleted?),</code></li>
<li class="ignored"><code>        no signal is sent.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        TODO: The behavior of django.contrib.* apps seems flawed in that</code></li>
<li class="ignored"><code>        they don't respect created_models.  Rather, they blindly execute</code></li>
<li class="ignored"><code>        over all models within the app sending the signal.  This is a</code></li>
<li class="ignored"><code>        patch we should push Django to make  For now, this should work.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if self.debug:</code></li>
<li class="missed"><code>            print(" - Sending post_syncdb signal for %s: %s" % (app_label, model_names))</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        app = models.get_app(app_label)</code></li>
<li class="executed"><code>        if not app:</code></li>
<li class="missed"><code>            return</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        created_models = []</code></li>
<li class="executed"><code>        for model_name in model_names:</code></li>
<li class="executed"><code>            model = models.get_model(app_label, model_name)</code></li>
<li class="executed"><code>            if model:</code></li>
<li class="executed"><code>                created_models.append(model)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if created_models:</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            if hasattr(dispatcher, "send"):</code></li>
<li class="ignored"><code>                # Older djangos</code></li>
<li class="missed"><code>                dispatcher.send(signal=models.signals.post_syncdb, sender=app,</code></li>
<li class="ignored"><code>                                app=app, created_models=created_models,</code></li>
<li class="ignored"><code>                                verbosity=verbosity, interactive=interactive)</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="executed"><code>                if self._is_multidb():</code></li>
<li class="ignored"><code>                    # Django 1.2+</code></li>
<li class="executed"><code>                    models.signals.post_syncdb.send(</code></li>
<li class="ignored"><code>                        sender=app,</code></li>
<li class="ignored"><code>                        app=app,</code></li>
<li class="ignored"><code>                        created_models=created_models,</code></li>
<li class="ignored"><code>                        verbosity=verbosity,</code></li>
<li class="ignored"><code>                        interactive=interactive,</code></li>
<li class="ignored"><code>                        db=self.db_alias,</code></li>
<li class="ignored"><code>                    )</code></li>
<li class="ignored"><code>                else:</code></li>
<li class="ignored"><code>                    # Django 1.1 - 1.0</code></li>
<li class="missed"><code>                    models.signals.post_syncdb.send(</code></li>
<li class="ignored"><code>                        sender=app,</code></li>
<li class="ignored"><code>                        app=app,</code></li>
<li class="ignored"><code>                        created_models=created_models,</code></li>
<li class="ignored"><code>                        verbosity=verbosity,</code></li>
<li class="ignored"><code>                        interactive=interactive,</code></li>
<li class="ignored"><code>                    )</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def mock_model(self, model_name, db_table, db_tablespace='',</code></li>
<li class="ignored"><code>                   pk_field_name='id', pk_field_type=models.AutoField,</code></li>
<li class="ignored"><code>                   pk_field_args=[], pk_field_kwargs={}):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        Generates a MockModel class that provides enough information</code></li>
<li class="ignored"><code>        to be used by a foreign key/many-to-many relationship.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Migrations should prefer to use these rather than actual models</code></li>
<li class="ignored"><code>        as models could get deleted over time, but these can remain in</code></li>
<li class="ignored"><code>        migration files forever.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Depreciated.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="executed"><code>        class MockOptions(object):</code></li>
<li class="executed"><code>            def __init__(self):</code></li>
<li class="executed"><code>                self.db_table = db_table</code></li>
<li class="executed"><code>                self.db_tablespace = db_tablespace or settings.DEFAULT_TABLESPACE</code></li>
<li class="executed"><code>                self.object_name = model_name</code></li>
<li class="executed"><code>                self.module_name = model_name.lower()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>                if pk_field_type == models.AutoField:</code></li>
<li class="executed"><code>                    pk_field_kwargs['primary_key'] = True</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>                self.pk = pk_field_type(*pk_field_args, **pk_field_kwargs)</code></li>
<li class="executed"><code>                self.pk.set_attributes_from_name(pk_field_name)</code></li>
<li class="executed"><code>                self.abstract = False</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            def get_field_by_name(self, field_name):</code></li>
<li class="ignored"><code>                # we only care about the pk field</code></li>
<li class="missed"><code>                return (self.pk, self.model, True, False)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>            def get_field(self, name):</code></li>
<li class="ignored"><code>                # we only care about the pk field</code></li>
<li class="missed"><code>                return self.pk</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        class MockModel(object):</code></li>
<li class="executed"><code>            _meta = None</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        # We need to return an actual class object here, not an instance</code></li>
<li class="executed"><code>        MockModel._meta = MockOptions()</code></li>
<li class="executed"><code>        MockModel._meta.model = MockModel</code></li>
<li class="executed"><code>        return MockModel</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _db_positive_type_for_alter_column(self, klass, field):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        A helper for subclasses overriding _db_type_for_alter_column:</code></li>
<li class="ignored"><code>        Remove the check constraint from the type string for PositiveInteger</code></li>
<li class="ignored"><code>        and PositiveSmallInteger fields.</code></li>
<li class="ignored"><code>        @param klass: The type of the child (required to allow this to be used when it is subclassed)</code></li>
<li class="ignored"><code>        @param field: The field to generate type for</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        super_result = super(klass, self)._db_type_for_alter_column(field)</code></li>
<li class="missed"><code>        if isinstance(field, (models.PositiveSmallIntegerField, models.PositiveIntegerField)):</code></li>
<li class="missed"><code>            return super_result.split(" ", 1)[0]</code></li>
<li class="missed"><code>        return super_result</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>    def _alter_add_positive_check(self, klass, field, name, params, sqls):</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code>        A helper for subclasses overriding _alter_add_column_mods:</code></li>
<li class="ignored"><code>        Add a check constraint verifying positivity to PositiveInteger and</code></li>
<li class="ignored"><code>        PositiveSmallInteger fields.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="missed"><code>        super(klass, self)._alter_add_column_mods(field, name, params, sqls)</code></li>
<li class="missed"><code>        if isinstance(field, (models.PositiveSmallIntegerField, models.PositiveIntegerField)):</code></li>
<li class="missed"><code>            uniq_hash = abs(hash(tuple(params.values())))</code></li>
<li class="missed"><code>            d = dict(</code></li>
<li class="ignored"><code>                     constraint = "CK_%s_PSTV_%s" % (name, hex(uniq_hash)[2:]),</code></li>
<li class="ignored"><code>                     check = "%s &gt;= 0" % self.quote_name(name))</code></li>
<li class="missed"><code>            sqls.append((self.add_check_constraint_fragment % d, []))</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># Single-level flattening of lists</code></li>
<li class="missed"><code>def flatten(ls):</code></li>
<li class="missed"><code>    nl = []</code></li>
<li class="missed"><code>    for l in ls:</code></li>
<li class="missed"><code>        nl += l</code></li>
<li class="missed"><code>    return nl</code></li>
  </ol>
</div>

<div class="nav">
  <a href="south.db.firebird.html">south.db.firebird</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="south.db.mysql.html">south.db.mysql</a>
</div>

  </body>
</html>

